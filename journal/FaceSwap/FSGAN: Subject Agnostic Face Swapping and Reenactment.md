# FSGAN: Subject Agnostic Face Swapping and Reenactment

## Abstract
We present Face Swapping GAN (FSGAN) for face swapping and reenactment. Unlike previous work, FSGAN is subject agnostic and can be applied to pairs of faces without requiring training on those faces. To this end, we describe a number of technical contributions. We derive a novel recurrent neural network (RNN)–based approach for face reenactment which adjusts for both pose and expression variations and can be applied to a single image or a video sequence. For video sequences, we introduce continuous interpolation of the face views based on reenactment, Delaunay Triangulation, and barycentric coordinates. Occluded face regions are handled by a face completion network. Finally, we use a face blending network for seamless blending of the two faces while preserving target skin color and lighting conditions. This network uses a novel Poisson blending loss which combines Poisson optimization with perceptual loss. We compare our approach to existing state-of-the-art systems and show our results to be both qualitatively and quantitatively superior
## 1. Inroduction
Face swapping is the task of transferring a face from source to target image, so that it seamlessly replaces a face appearing in the target and produces a realistic result (Fig. 1 left). Face reenactment (aka face transfer or puppeteering) uses the facial movements and expression deformations of a control face in one video to guide the motions and de formations of a face appearing in a video or image (Fig. 1 right). Both tasks are attracting significant research attention due to their applications in entertainment [1, 21, 48], privacy [6, 26, 32], and training data generation. Previous work proposed either methods for swapping or for reenactment but rarely both. Earlier methods relied on underlying 3D face representations [46] to transfer or control facial appearances. Face shapes were either estimated from the input image [44, 42, 35] or were fixed [35]. The 3D shape was then aligned with the input images [10] and used as a proxy when transferring intensities (swapping) or controlling facial expression and viewpoints (reenactment). Recently, deep network–based methods were proposed for face manipulation tasks. Generative adversarial networks (GANs) [13], for example, were shown to successfully generate realistic images of fake faces. Conditional GANs (cGANs) [31, 17, 47] were used to transform an image depicting real data from one domain to another and inspired multiple face reenactment schemes [37, 50, 40]. Finally, the DeepFakes project [12] leveraged cGANs for face swapping in videos, making swapping widely accessible to non-experts and receiving significant public attention. Those methods are capable of generating realistic face images by replacing the classic graphics pipeline. They all, however, still implicitly use 3D face representations. Some methods relied on latent feature space domain separation [45, 34, 33]. These methods decompose the identity component of the face from the remaining traits, and encode identity as the manifestation of latent feature vectors, resulting in significant information loss and limiting the quality of the synthesized images. Subject specific methods [42, 12, 50, 22] must be trained for each subject or pair of subjects and so require expensive subject specific data— typically thousands of face images—to achieve reasonable results, limiting their potential usage. Finally, a major concern shared by previous face synthesis schemes, particularly the 3D based methods, is that they all require special care when handling partially occluded faces. We propose a deep learning–based approach to face swapping and reenactment in images and videos. Unlike previous work, our approach is subject agnostic: it can be applied to faces of different subjects without requiring subject specific training. Our Face Swapping GAN (FSGAN) is end-to-end trainable and produces photo realistic, temporally coherent results. We make the following contributions:
- Subject agnostic swapping and reenactment. To the best of our knowledge, our method is the first to simultaneously manipulate pose, expression, and identity without requiring person-specific or pair-specific training, while producing high quality and temporally coherent results.
- Multiple view interpolation. We offer a novel scheme for interpolating between multiple views of the same face in a continuous manner based on reenactment, Delaunay Triangulation and barycentric coordinates.
- New loss functions. We propose two new losses: A stepwise consistency loss, for training face reenactment progressively in small steps, and a Poisson blending loss, to train the face blending network to seamlessly integrate the source face into its new context.
We test our method extensively, reporting qualitative and quantitative ablation results and comparisons with state of the art. The quality of our results surpasses existing work even without training on subject specific images.

## 2. Related work
Methods for manipulating the appearances of face images, particularly for face swapping and reenactment, have a long history, going back nearly two decades. These methods were originally proposed due to privacy concerns [6, 26, 32] though they are increasingly used for recreation [21] or entertainment (e.g., [1, 48]). 
**3D based methods.**  
The earliest swapping methods required manual involvement [6]. An automatic method was proposed a few years later [4]. More recently, Face2Face transferred expressions from source to target face [44]. Transfer is performed by fitting a 3D morphable face model (3DMM) [5, 7, 11] to both faces and then applying the expression components of one face onto the other with care given to interior mouth regions. The reenactement method of Suwajanakorn et al. [42] synthesized the mouth part of the face using a reconstructed 3D model of (former president) Obama, guided by face landmarks, and using a similar strategy for filling the face interior as in Face2Face. The expression of frontal faces was manipulated by AverbuchElor et al. [3] by transferring the mouth interior from source to target image using 2D wraps and face landmarks.  
  
Finally, Nirkin et al. [35] proposed a face swapping method, showing that 3D face shape estimation is unnecessary for realistic face swaps. Instead, they used a fixed 3D face shape as the proxy [14, 29]. Like us, they proposed a face segmentation method, though their work was not endto-end trainable and required special attention to occlusions. We show our results to be superior than theirs.   
**GAN-based methods.**  
GANs [13] were shown to generate fake images with the same distribution as a target domain. Although successful in generating realistic appearances, training GANs can be unstable and restricts their application to low-resolution images. Subsequent methods, however, improved the stability of the training process [28, 2]. Karras et al. [20] train GANs using a progressive multiscale scheme, from a low to high image resolutions. CycleGAN [52] proposed a cycle consistency loss, allowing training of unsupervised generic transformations between different domains. A cGAN with L1 loss was applied by Isola et al. [17] to derive the pix2pix method, and was shown to produce appealing synthesis results for applications such as transforming edges to faces. 

**Facial manipulation using GANs.**  
Pix2pixHD [47] used GANs for high resolution image-to-image translation by applying a multi-scale cGAN architecture and adding a perceptual loss [18]. GANimation [37] proposed a dual generator cGAN conditioned on emotion action units, that generates an attention map. This map was used to interpolate between the reenacted and original images, to preserve the background. GANnotation [40] proposed deep facial reenactment driven by face landmarks. It generates images progressively using a triple consistency loss: it first frontalizes an image using landmarks then processes the frontal face.   
  
Kim et al. [22] recently proposed a hybrid 3D/deep method. They render a reconstructed 3DMM of a specific subject using a classic graphic pipeline. The rendered image is then processed by a generator network, trained to map synthetic views of each subject to photo-realistic images.  
  
Finally, feature disentanglement was proposed as a means for face manipulation. RSGAN [34] disentangles the latent representations of face and hair whereas FSNet [33] proposed a latent space which separates identity and geometric components, such as facial pose and expression.  

## 3. Face swapping GAN
In this work we introduce the Face Swapping GAN (FSGAN), illustrated in Fig. 2. Let Is be the source and It the target images of faces Fs ∈ Is and Ft ∈ It, respectively. We aim to create a new image based on It, where Ft is replaced by Fs while retaining the same pose and expression. FSGAN consists of three main components. The first, detailed in Sec. 3.2 (Fig. 2(a)), consists of a reenactment generator Gr and a segmentation CNN Gs. Gr is given a heatmaps encoding the facial landmarks of Ft, and generates the reenacted image Ir, such that Fr depicts Fs at the same pose and expression of Ft. It also computes Sr: the segmentation mask of Fr. Component Gs computes the face and hair segmentations of Ft. The reenacted image, Ir, may contain missing face parts, as illustrated in Fig. 2 and Fig. 2(b). We therefore apply the face inpainting network, Gc, detailed in Sec. 3.4 using the segmentation St, to estimate the missing pixels. The final part of the FSGAN, shown in Fig. 2(c) and Sec. 3.5, is the blending of the completed face Fc into the target image It to derive the final face swapping result. The architecture of our face segmentation network, Gs, is based on U-Net [38], with bilinear interpolation for upsampling. All our other generators—Gr, Gc, and Gb— are based on those used by pix2pixHD [47], with coarseto-fine generators and multi-scale discriminators. Unlike pix2pixHD, our global generator uses a U-Net architecture with bottleneck blocks [15] instead of simple convolutions and summation instead of concatenation. As with the segmentation network, we use bilinear interpolation for upsampling in both global generator and enhancers. The actual number of layers differs between generators.
Following others [50], training subject agnostic face reenactment is non-trivial and might fail when applied to unseen face images related by large poses. To address this challenge, we propose to break large pose changes into small manageable steps and interpolate between the closest available source images corresponding to a target’s pose. These steps are explained in the following sections.  
  
### 3.1. Training losses
**Domain specific perceptual loss.**   
To capture fine facial details we adopt the perceptual loss [18], widely used in recent work for face synthesis [40], outdoor scenes [47], and super resolution [25]. Perceptual loss uses the feature maps of a pretrained VGG network, comparing high frequency details using a Euclidean distance. We found it hard to fully capture details inherent to face images, using a network pretrained on a generic dataset such as ImageNet. Instead, our network is trained on the target domain: We therefore train multiple VGG-19 networks [41] for face recognition and face attribute classification. Let Fi ∈ R Ci×Hi×Wi be the feature map of the i-th layer of our network, the perceptual loss is given by  
![image](https://user-images.githubusercontent.com/40943064/147675589-5de62522-a872-422f-97a2-60ae02164d49.png)  

**Reconstruction loss.**  
While the perceptual loss of Eq. (1) captures fine details well, generators trained using only that loss, often produce images with inaccurate colors, corresponding to reconstruction of low frequency image content. We hence also applied a pixelwise L1 loss to the generators:
![image](https://user-images.githubusercontent.com/40943064/147675636-d84e98b4-f3d9-4c18-996b-97c4e1538928.png)  
  
The overall loss is then given by  
![image](https://user-images.githubusercontent.com/40943064/147675660-24dccd83-70e9-40cb-b5e1-dd8ec838b070.png)  
The loss in Eq. (3) was used with all our generators.  
  
Adversarial loss. To further improve the realism of our generated images we use an adversarial objective [47]. We utilized a multi-scale discriminator consisting of multiple discriminators, D1, D2, ..., Dn, each one operating on a different image resolution. For a generator G and a multi-scale discriminator D, our adversarial loss is defined by:  

![image](https://user-images.githubusercontent.com/40943064/147675735-d41f9c23-eeeb-4a98-a7d6-5590932d8cde.png)


### 3.2. Face reenactment and segmentation
Given an image I ∈ R 3×H×W and a heatmap representation H(p) ∈ R 70×H×W of facial landmarks, p ∈ R 70×2 , we define the face reenactment generator, Gr, as the mapping Gr :  R 3×H×W , R 70×H×W → R 3×H×W . Let vs, vt ∈ R 70×3 and es, et ∈ R 3 , be the 3D landmarks and Euler angles corresponding to Fs and Ft. We generate intermediate 2D landmark positions pj by interpolating between es and et, and the centroids of vs and vt, using intermediate points for which we project vs back to Is. We define the reenactment output recursively for each iteration 1 ≤ j ≤ n as  
![image](https://user-images.githubusercontent.com/40943064/147675789-52466c4b-1e20-453a-9176-de13bd9ab17f.png)  
Similar to others [37], the last layer of the global generator and each of the enhancers in Gr is split into two heads: the first produces the reenacted image and the second the segmentation mask. In contrast to binary masks used bu others [37], we consider the face and hair regions separately. The binary mask implicitly learned by the reenactment network captures most of the head including the hair, which we segment separately. Moreover, the additional hair segmentation also improves the accuracy of the face segmentation. The face segmentation generator Gs is defined as Gr : R 3×H×W → R 3×H×W , where given an RGB image it output a 3-channels segmentation mask encoding the background, face, and hair.  
Training. Inspired by the triple consistency loss [40], we propose a stepwise consistency loss. Given an image pair (Is, It) of the same subject from a video sequence, let Irn be the reenactment result after n iterations, and Iet, Iern be the same images with their background removed using the segmentation masks St and Srj , respectively. The stepwise consistency loss is defined as: Lrec(Iern , Iet). The final objective for the Gr: L(Gr) =λstepwiseLrec(Iern , Iet) + λrecLrec(Ier, Iet) + λadvLadv + λsegLpixel(Sr, St). (7) For the objective of Gs we use the standard crossentropy loss, Lce, with additional guidance from Gr: L(Gs) = Lce + λreenactmentLpixel(St, St r ), (8) where S t r is the segmentation mask result of Gr(It; H(pt)) and pt is the 2D landmarks corresponding to It. We train both Gr and Gs together, in an interleaved fashion. We start with training Gs for one epoch followed by the training of Gr for an additional epoch, increasing λreenactment as the training progresses. We have found that training Gr and Gs together helps filtering noise learned from coarse face and hair segmentation labels. 

### 3.3. Face view interpolation
Standard computer graphics pipelines project textured mesh polygons onto a plane for seamless rendering [16]. We propose a novel, alternative scheme for continuous interpolation between face views. This step is an essential phase of our method, as it allows using the entire source video sequence, without training our model on a particular video frame, making it subject agnostic. Given a set of source subject images, {Is1 , . . . , Isn }, and Euler angles, {e1, . . . , en}, of the corresponding faces {Fs1 , . . . , Fsn }, we construct the appearance map of the source subject, illustrated in Fig. 3(a). This appearance map embeds head poses in a triangulated plane, allowing head poses to follow continuous paths. We start by projecting the Euler angles {e1, . . . , en} onto a plane by dropping the roll angle. Using a k-d tree data structure [16], we remove points in the angular domain that are too close to each other, prioritizing the points for which the corresponding Euler angles have a roll angle closer to zero. We further remove motion blurred images. Using the remaining points, {x1, . . . , xm}, and the four boundary points, yi ∈ [−75, 75] × [−75, 75], we build a mesh, M, in the angular domain by Delaunay Triangulation. For a query Euler angle, et, of a face, Ft, and its corresponding projected point, xt, we find the triangle T ∈ M that contains xt. Let xi1 , xi2 , xi3 be the vertices of T and Isi1 , Isi2 , Isi3 be the corresponding face views. We calculate the barycentric coordinates, λ1, λ2, λ3 of xt, with respect to xi1 , xi2 , xi3 . The interpolation result Ir is then 
![image](https://user-images.githubusercontent.com/40943064/147675884-8dc8c5ec-dc8d-46c5-8a89-006c3ae83872.png)  

where pt are the 2D landmarks of Ft. If any vertices of the triangle are boundary points, we exclude them from the interpolation and normalize the weights, λi , to sum to one. A face view query is illustrated in Fig. 3(b,c). To improve interpolation accuracy, we use a horizontal flip to fill in views when the appearance map is one-sided with respect to the yaw dimension, and generate artificial views using Gr when the appearance map is too sparse.
### 3.4. Face inpainting
Occluded regions in the source face Fs cannot be rendered on the target face, Ft. Nirkin et al. [35] used the segmentations of Fs and Ft to remove occluded regions, rendering (swapping) only regions visible in both source and target faces. Large occlusions and different facial textures can cause noticeable artifacts in the resulting images. To mitigate such problems, we apply a face inpainting generator, Gc (Fig. 2(b)). Gc renders face image Fs such that the resulting face rendering ˜Ir covers entire segmentation mask St (of Ft), thereby resolving such occlusion. Given the reenactment result, Ir, its corresponding segmentation, Sr, and the target image with its background removed, ˜It, all drawn from the same identity, we first augment Sr by simulating common face occlusions due to hair, by randomly removing ellipse-shaped parts, in various sizes and aspect ratios from the border of Sr. Let ˜Ir be Ir with its background removed using the augmented version of Sr, and Ic the completed result from applying Gc on ˜Ir. We define our inpainting generator loss as
![image](https://user-images.githubusercontent.com/40943064/147676018-9e56f529-c133-4221-8ae5-cd651e5da573.png)  
where Lrec and Ladv are the reconstruction and adversarial losses of Sec. 3.1  

### 3.5. Face blending
The last step of the proposed face swapping scheme is blending of the completed face Fc with its target face Ft (Fig. 2(c)). Any blending must account for, among others, different skin tones and lighting conditions. Inspired by previous uses of Poisson blending for inpainting [51] and blending [49], we propose a novel Poisson blending loss. Let It be the target image, I t r the image of the reenacted face transferred onto the target image, and St the segmentation mask marking the transferred pixels. Following [36], we define the Poisson blending optimization as  
![image](https://user-images.githubusercontent.com/40943064/147676041-e2e31359-6614-4234-9a42-2b4ad40f6567.png)  
where ∇ (·) is the gradient operator. We combine the Poisson optimization in Eq. (11) with the perceptual loss. The Poisson blending loss is then L(Gb)  
![image](https://user-images.githubusercontent.com/40943064/147676056-fc1775bd-dad5-4f3d-8547-fed79ebc6720.png)  

## 4. Datasets and training
We use the video sequences of the IJB-C dataset [30] to train our generator, Gr, for which we automatically ex- tracted the frames depicting particular subjects. IJB-C contains ∼11k face videos, of which we used 5,500 which were in high definition. Similar to the frame pruning approach of Sec. 3.3, we prune the face views that are too close together as well as motion-blurred frames. We apply the segmentation CNN, Gs, to the frames, and prune the frames for which less than 15% of the pixels in the face bounding box were classified as face pixels. We used dlib’s face verification1 to group frames according to the subject identity, and limit the number of frames per subject to 100, by choosing frames with the maximal variance in 2D landmarks. In each training iteration, we choose the frames Is and It from two randomly chosen subjects. We trained VGG-19 CNNs for the perceptual loss on the VGGFace2 dataset [9] for face recognition and the CelebA [27] dataset for face attribute classification. The VGGFace2 dataset contains 3.3M images depicting 9,131 identities, whereas CelebA contains 202,599 images, annotated with 40 binary attributes. We trained the segmentation CNN, Gs, on data used by others [35], consisting of ∼10k face images labeled with face segmentations. We also used the LFW Parts Labels set [19] with ∼3k images labeled for face and hair segmentations, removing the neck regions using facial landmarks. We used additional 1k images and corresponding hair segmentations from the Figaro dataset [43]. Finally, FaceForensics++ [39] provides 1000 videos, from which they generated 1000 synthetic videos on random pairs using DeepFakes [12] and Face2Face [44].
### 4.1. Datasets and processing

### 4.2. Training details
We train the proposed generators from scratch, where the weights were initialized randomly using a normal distribution. We use Adam optimization [24] (β1 = 0.5, β2 = 0.999) and a learning rate of 0.0002. We reduce this rate by half every ten epochs. The following parameters were used for all the generators: λperc = 1, λpixel = 0.1, λadv = 0.001, λseg = 0.1, λrec = 1, λstepwise = 1, where λreenactment is linearly increased from 0 to 1 during training. All of our networks were trained on eight NVIDIA Tesla V100 GPUs and an Intel Xeon CPU. Training of Gs required six hours to converge, while the rest of the networks converged in two days. All our networks, except for Gs, were trained using a progressive multi scale approach, starting with a resolution of 128×128 and ending at 256×256. Inference rate is ∼30fps for reenactment and ∼10fps for swapping on one NVIDIA Tesla V100 GPU.
## 5. Experimental results
We performed extensive qualitative and quantitative experiments to verify the proposed scheme. We compare our 1Available: http://dlib.net/ method to two previous face swapping methods: DeepFakes [12] and Nirkin et al. [35], and the Face2Face reenactment scheme [44]. We conduct all our experiments on videos from FaceForensics++ [39], by running our method on the same pairs they used. We further report ablation studies showing the importance of each component in our pipeline.
### 5.1. Qualitative face reenactment results
Fig. 4 shows our raw face reenactment results, without background removal. We chose examples of varying ethnicity, pose, and expression. A specifically interesting example can be seen in the rightmost column, showing our method’s ability to cope with extreme expressions. To show the importance of iterative reenactment, Fig 5 provides reenactments of the same subject for both small and large angle differences. As evident from the last column, for large angle differences, the identity and texture are better preserved using multiple iterations.
### 5.2. Qualitative face swapping results
Fig. 6 offers face swapping examples taken from FaceForensics++ videos, without training our model on these videos. We chose examples that represent different poses and expression, face shapes, and hair occlusions. Because Nirkin et al. [35] is an image-to-image face swapping method, to be fair in our comparison, for each frame in the target video we select the source frame with the most similar pose. To compare FSGAN in a video-to-video scenario, we use our face view interpolation described in Sec. 3.3.
### 5.3. Comparison to Face2Face
We compare our method to Face2Face [44] on the expression only reenactment problem. Given a pair of faces Fs ∈ Is and Ft ∈ It the goal is to transfer the expression from Is to It. To this end, we modify the corresponding 2D landmarks of Ft by swapping in the mouth points of the 2D landmarks of Fs, similarly to how we generate the intermediate landmarks in Sec. 3.2. The reenactment result is then given by Gr(It; H(ˆpt)), where pˆt are the modified landmarks. The examples are shown in Fig. 7.
### 5.4. Quantitative results
We report quantitative results, conforming to how we defined the face swapping problem: we validate how well methods preserve the source subject identity, while retaining the same pose and expression of the target subject. To this end, we first compare the face swapping result, Fb, of each frame to its nearest neighbor in pose from the subject face views. We use the dlib [23] face verification method to compare identities and the structural similarity index method (SSIM) to compare their quality. To measure pose accuracy, we calculate the Euclidean distance between the Euler angles of Fb to the original target image, It. Similarly, the accuracy of the expression is measured as the Euclidean distance between the 2D landmarks. Pose error is measured in degrees and the expression error is measured in pixels. We computes the mean and variance of those measurements on the first 100 frames of the first 500 videos in FaceForensics++, averaging them across the videos. As baselines, we use Nirkin et al. [35] and DeepFakes [12]. Evident from the first two columns of Table 1, our approach preserves identity and image quality similarly to previous methods. The two rightmost metrics in Table 1 show that our method retains pose and expression much better than its baselines. Note that the human eye is very sensitive to artifacts on faces. This should be reflected in the quality score but those artifacts usually capture only a small part of the image and so the SSIM score does not reflect them well.
### 5.5. Ablation study
We performed ablation tests with four configurations of our method: Gr only, Gr + Gc, Gr + Gb, and our full pipeline. The segmentation network, Gs, is used in all configurations. Qualitative results are provided in Fig. 8. Quantitative ablation results are reported in Table 2. Verification scores show that source identities are preserved across all pipeline networks. From Euler and landmarks scores we see that target poses and expressions are best retained with the full pipeline. Error differences are not extreme, suggesting that the inpainting and blending generators, Gc and Gb, respectively, preserve pose and expression similarly well. There is a slight drop in the SSIM, due to the additional networks and processing added to the pipeline.


## 6. Conclusion
Limitations. Fig. 5 shows our reenactment results for different facial yaw angles. Evidently, the larger the angular differences, the more identity and texture quality degrade. Moreover, too many iterations of the face reenactment generator blur the texture. Unlike 3DMM based methods, e.g., Face2Face [44], which warp textures directly from the image, our method is limited to the resolution of the training data. Another limitation arises from using a sparse landmark tracking method that does not fully capture the complexity of facial expressions. Discussion. Our method eliminates laborious, subjectspecific, data collection and model training, making face swapping and reenactment accessible to non-experts. We feel strongly that it is of paramount importance to publish such technologies, in order to drive the development of technical counter-measures for detecting such forgeries, as well as compel law makers to set clear policies for addressing their implications. Suppressing the publication of such methods would not stop their development, but rather make them available to select few and potentially blindside policy makers if it is misused.
